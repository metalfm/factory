package gen

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"maps"
	"strings"

	"github.com/metalfm/factory/internal/fc"
)

type generator interface {
	Generate(
		fieldName []*ast.Ident,
		fieldType ast.Expr,
	) (
		fields []field,
		imports map[string]string,
	)
}

type field struct {
	Name string
	Type string
}

type Generator struct {
	buf        bytes.Buffer // Accumulated output.
	pkg        *fc.Package  // Package we are scanning.
	pkgOutName string
	gen        generator
	imports    map[string]string
}

func NewGenerator(
	pkg *fc.Package,
	pkgOutName string,
	imports map[string]string,
	params *ast.FieldList,
	defs map[string]struct{},
) *Generator {
	return &Generator{
		buf:        bytes.Buffer{},
		pkg:        pkg,
		pkgOutName: pkgOutName,
		gen: newFieldComplex([]generator{
			newFieldObj(pkg.Path, params, defs),
			newFieldSimple(),
			newFieldSel(imports),
			newFieldInterface(),
		}),
		imports: map[string]string{
			"fmt":     "fmt",
			"context": "context",
			"atomic":  "sync/atomic",
			pkg.Name:  pkg.Path,
		},
	}
}

func (slf *Generator) Generate(st fc.Struct) *Generator {
	imports := make(map[string]string, 10)
	fields := make([]field, 0, 10)
	generics := make([]field, 0, 10)

	if st.Params != nil {
		for _, l := range st.Params.List {
			f, i := slf.gen.Generate(l.Names, l.Type)
			if len(f) > 0 {
				generics = append(generics, f...)
				maps.Copy(imports, i)
			}
		}
	}

	for _, l := range st.Type.Fields.List {
		f, i := slf.gen.Generate(l.Names, l.Type)
		if len(f) > 0 {
			maps.Copy(imports, i)
			fields = append(fields, f...)
		}
	}

	stName := st.Name
	stTypePtr := entityTypePtr(slf.pkg.Name, stName)
	stType := entityType(slf.pkg.Name, stName)

	slf.writeHead()

	slf.writeImports(imports)
	slf.writeDefinitions(stName, stTypePtr, fields, generics)
	slf.writeConstructor(stName, stTypePtr, stType, fields, generics)
	slf.WriteMethods(stName, stTypePtr, stType, fields, generics)

	return slf
}

func (slf *Generator) Format() ([]byte, error) {
	//return slf.buf.Bytes(), nil

	src, err := format.Source(slf.buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("format generated code: %w", err)
	}

	return src, nil
}

func (slf *Generator) writeHead() {
	fmt.Fprint(&slf.buf, "// Code generated by fcgen; DO NOT EDIT.")
	fmt.Fprint(&slf.buf, "\n\n")
	fmt.Fprintf(&slf.buf, "package %s\n", slf.pkgOutName)
}

func (slf *Generator) writeImports(imports map[string]string) {
	out := make(map[string]string, len(imports)+len(slf.imports))

	maps.Copy(out, slf.imports)
	maps.Copy(out, imports)

	str := ""

	for alias, imp := range out {
		str += fmt.Sprintf("\t%s %q\n", alias, imp)
	}

	fmt.Fprintf(&slf.buf, "import (\n%s)", str)
}

func (slf *Generator) writeDefinitions(
	stName,
	stType string,
	fields []field,
	generics []field,
) {
	defs := make([]string, 0, len(fields))

	for _, f := range fields {
		gName := genericsName(generics)

		defs = append(
			defs,
			fmt.Sprintf("on%s func(e %s%s)", f.Name, stType, gName),
			fmt.Sprintf("set%s bool", f.Name),
		)
	}

	r := strings.NewReplacer(
		":fcName", fcName(stName),
		":gFull", genericsFull(generics),
		":gName", genericsName(generics),
		":entity", stType,
		":definitions", strings.Join(defs, "\n\t"),
	)

	tpl := `
type :fcName:gFull struct {
	entity   :entity:gName
	seq      func(e :entity:gName)
	seqInt   func(e :entity:gName)
	seqInt64 func(e :entity:gName)
	onCreate func(ctx context.Context, e :entity:gName) error
    :definitions
}`

	fmt.Fprint(&slf.buf, r.Replace(tpl))
}

func (slf *Generator) writeConstructor(
	stName,
	stTypePtr,
	stType string,
	fields []field,
	generics []field,
) {
	defs := ""
	gName := genericsName(generics)

	for _, f := range fields {
		defs += fmt.Sprintf("on%s: func(e %s%s) {},\n", f.Name, stTypePtr, gName)
	}

	r := strings.NewReplacer(
		":fcName", fcName(stName),
		":gFull", genericsFull(generics),
		":gName", gName,
		":stName", stName,
		":fcPtr", fcPtr(stName),
		":entityPtr", stTypePtr,
		":ent", stType,
		":defs", defs,
	)

	tpl := `
func NewFactory:stName:gFull(e :ent:gName) :fcPtr:gName {
	return &:fcName:gName{
		entity: &e,
		seq: func(e :entityPtr:gName) {},
		seqInt: func(e :entityPtr:gName) {},
		seqInt64: func(e :entityPtr:gName) {},
		onCreate: func(ctx context.Context, e :entityPtr:gName) error { return nil },
:defs
	}
}
`

	fmt.Fprint(&slf.buf, r.Replace(tpl))
}

func (slf *Generator) WriteMethods(
	stName,
	stTypePtr,
	stType string,
	fields []field,
	generics []field,
) {
	methods := make([]string, 0, len(fields))
	setters := make([]string, 0, len(fields))
	gName := genericsName(generics)

	for _, f := range fields {
		methods = append(methods, strings.NewReplacer(
			":fcPtr", fcPtr(stName),
			":gName", gName,
			":fieldName", f.Name,
			":fieldType", f.Type,
			":entity", stTypePtr,
		).Replace(`
func (slf :fcPtr:gName) :fieldName(v :fieldType) :fcPtr:gName {
	slf.entity.:fieldName = v
    slf.set:fieldName = true
	return slf
}
`))
		methods = append(methods, strings.NewReplacer(
			":fcPtr", fcPtr(stName),
			":gName", gName,
			":fieldName", f.Name,
			":fieldType", f.Type,
			":entity", stTypePtr,
		).Replace(`
func (slf :fcPtr:gName) On:fieldName(fn func(e :entity:gName)) :fcPtr:gName {
	slf.on:fieldName = fn
	return slf
}
`))
		setter := fmt.Sprintf(`
if !slf.set%s {
  slf.on%s(slf.entity)
}
`, f.Name, f.Name)

		setters = append(setters, setter)
	}

	fmt.Fprint(&slf.buf, strings.Join(methods, ""))

	if len(methods) > 0 {
		fmt.Fprint(&slf.buf, "\n")
	}

	r := strings.NewReplacer(
		":fcPtr", fcPtr(stName),
		":gName", gName,
		":entityPtr", stTypePtr,
		":ent", stType,
		":setters", strings.Join(setters, "\n"),
	)

	tpl := `
func (slf :fcPtr:gName) Seq(fn func(e :entityPtr:gName)) :fcPtr:gName {
	slf.seq = fn
	return slf
}

func (slf :fcPtr:gName) SeqInt(fn func(e :entityPtr:gName, n int)) :fcPtr:gName {
	var seq int32
	slf.seqInt = func(e :entityPtr:gName) {
		v := atomic.AddInt32(&seq, 1)
		fn(e, int(v))
	}
	return slf
}

func (slf :fcPtr:gName) SeqInt64(fn func(e :entityPtr:gName, n int64)) :fcPtr:gName {
	var seq int64
	slf.seqInt64 = func(e :entityPtr:gName) {
		v := atomic.AddInt64(&seq, 1)
		fn(e, v)
	}
	return slf
}

func (slf :fcPtr:gName) OnCreate(fn func(ctx context.Context, e :entityPtr:gName) error) :fcPtr:gName {
	slf.onCreate = fn
	return slf
}

func (slf :fcPtr:gName) MustBuild() :ent:gName {
	return slf.MustBuildCtx(context.Background())
}

func (slf :fcPtr:gName) MustBuildCtx(ctx context.Context) :ent:gName {
	slf.seq(slf.entity)
	slf.seqInt(slf.entity)
	slf.seqInt64(slf.entity)

:setters

	err := slf.onCreate(ctx, slf.entity)
	if err != nil {
		panic(fmt.Errorf("factory.OnCreate: %w", err))
	}

	return *slf.entity
}`

	fmt.Fprint(&slf.buf, r.Replace(tpl))
}

//func collect(gens []generator) (map[string]string, []field) {
//	imports := map[string]string{}
//	fields := make([]field, 0, 10)
//
//	for _, g := range gens {
//		maps.Copy(imports, g.Imports())
//		fields = append(fields, g.Fields()...)
//	}
//
//	return imports, fields
//}

func fcPtr(stName string) string {
	return "*" + fcName(stName)
}

func fcName(name string) string {
	return "factory" + name
}

func entityTypePtr(pkgName, stName string) string {
	return "*" + entityType(pkgName, stName)
}

func entityType(pkgName, stName string) string {
	return fmt.Sprintf("%s.%s", pkgName, stName)
}

func genericsFull(fields []field) string {
	if len(fields) == 0 {
		return ""
	}

	g := make([]string, 0, len(fields))
	for _, f := range fields {
		g = append(g, fmt.Sprintf("%s %s", f.Name, f.Type))
	}

	return fmt.Sprintf("[%s]", strings.Join(g, ", "))

}

func genericsName(fields []field) string {
	if len(fields) == 0 {
		return ""
	}

	g := make([]string, 0, len(fields))
	for _, f := range fields {
		g = append(g, f.Name)
	}

	return fmt.Sprintf("[%s]", strings.Join(g, ", "))
}
